<html>
  <head>
    <script type="text/javascript">
      (function() {
        /**
         * Sort helper object.
         * @constructor
         */
        function Sort() {
          /**
           * Perform a Bubble Sort on an array.
           *
           * Sort is performed in place and assumes conflict ordering is
           * not important.
           *
           * @param {Array} array the array to sort.
           */
          this.bubbleSort = function(array) {
            const self = this;
            array.forEach((_, i) => {
              array.forEach((_, j) => {
                if (array[i] < array[j]) {
                  self.swap(array, i, j);
                }
              });
            });
          };

          /**
           * Perform an Heap Sort on an array.
           *
           * Sort is performed in place and assumes conflict ordering is
           * not important.
           *
           * @param {Array} array the array to sort.
           */
          this.heapSort = function(array) {

          };

          /**
           * Perform an Insertion Sort on an array.
           *
           * Sort is performed in place and assumes conflict ordering is
           * not important.
           *
           * @param {Array} array the array to sort.
           */
          this.insertionSort = function(array) {
            const self = this;
            array.forEach((_, i) => {
              var j = 0;

              while(j < i) {
                if (array[j] > array[i]) {
                  self.reposition(array, i, j);
                  break;
                }
                j++;
              }
            });
          };

          /**
           * Perform a Merge Sort on an array.
           *
           * Sort is creates a new array in the return val and, where conflict arises,
           * original order is maintained.
           *
           * @param {Array} array the array to sort.
           * @return the sorted array.
           */
          this.mergeSort = function(array) {
            if (array.length < 2 || (array.length === 2 && array[1] >= array[0])) {
              return array;
            } else if (array.length === 2 && array[0] > array[1]) {
              return [array[1], array[0]];
            } else {
              const mid = Math.floor(array.length / 2);
              const firstHalf = this.mergeSort(array.slice(0, mid));
              const secondHalf = this.mergeSort(array.slice(mid));
              return merge(firstHalf, secondHalf);
            }

            function merge (first, second) {
              const result = [];
              var i = 0, j = 0;

              while(i < first.length && j < second.length) {
                if (first[i] > second[j]) {
                  result.push(second[j]);
                  j++;
                } else {
                  result.push(first[i]);
                  i++;
                }
              }

              return result.concat(first.slice(i), second.slice(j));
            }
          };

          /**
           * Perform a Quick Sort on an array. Sort is performed in place and assumes
           * conflict order is not important.
           */
          this.quickSort = function(array, low, high) {
            const self = this;

            if (!low) {
              low = 0;
            }
            if (!high) {
              high = array.length - 1;
            }

            if (low < high) {
              const partitionIndex = partition(low, high);
              this.quickSort(array, low, partitionIndex - 1);
              this.quickSort(array, partitionIndex + 1, high);
            }

            function partition(low, high) {
              const pivot = array[high];
              var pivotIndex = low;

              for (var j = pivotIndex; j < high; j ++) {
                if (array[j] <= pivot) {
                  self.swap(array, pivotIndex, j);
                  pivotIndex++;
                }
              }

              self.swap(array, pivotIndex, high);

              return pivotIndex;
            }
          };

          /**
           * Perform a Selection Sort on an array.
           *
           * Sort is performed in place and assumes conflict ordering is
           * not important.
           *
           * This method could use Math.min.apply and .slice to determine the
           * least value in an array but doesn't to display use of tracking multiple
           * positions.
           *
           * @param {Array} array the array to sort.
           */
          this.selectionSort = function(array) {
            const self = this;

            array.forEach((_, i) => {
              var least = Number.MAX_SAFE_INTEGER;
              var leastIndex = i;
              for (var j = i; j < array.length; j++) {
                const next = array[j];
                if (next < least) {
                  least = next;
                  leastIndex = j;
                }
              }
              if (leastIndex !== i) {
                self.swap(array, i, leastIndex);
              }
            });
          };

          /**
           * Reposition an element in array.
           *
           * @param {Array} array the array in which to move elements.
           * @param {Number} from the index of the element to move.
           * @param {Number} to the index to move the element to.
           */
          this.reposition = function(array, from, to) {
            array.splice(to, 0, array.splice(from, 1)[0]);
          };

          /**
           * Swap two elements in place, in an array.
           *
           * @param {Array} array they array in which to swap elements.
           * @param {Number} i the index of the first element to swap.
           * @param {Number} j the index of the second element to swap.
           */
          this.swap = function(array, i ,j) {
            const tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
          };
        }

        var s = new Sort();

        const values = [84, 94, 44, 55, 91, 56, 54, 33, 77, 56, 66, 95, 12, 72, 100, 57, 65, 18, 51, 35, 16, 60, 18, 50, 56, 9, 93, 30, 54, 66, 61, 33, 61, 97, 65, 18, 42, 38, 85, 41, 90, 22, 42, 72, 10, 25, 33, 54, 63, 76, 7, 38, 18, 68, 29, 66, 35, 83, 82, 98, 61, 93, 33, 84, 91, 36, 33, 40, 95, 17, 16, 81, 36, 100, 92, 94, 85, 55, 18, 75, 17, 96, 77, 65, 57, 21, 54, 27, 77, 55, 48, 91, 100, 84, 58, 99, 51, 19, 67, 34];

        const bubbleSort = values.slice(0);
        s.bubbleSort(bubbleSort)
        console.log(bubbleSort);

        const selectionSort = values.slice(0);
        s.selectionSort(selectionSort)
        console.log(selectionSort);

        const insertionSort = values.slice(0);
        s.insertionSort(insertionSort)
        console.log(insertionSort);

        console.log(s.mergeSort(values));

        const quickSort = values.slice(0);
        s.quickSort(quickSort)
        console.log(quickSort);

        const heapSort = values.slice(0);
        s.quickSort(heapSort)
        console.log(heapSort);
      })();
    </script>
  </head>
  <body>

  </body>
</html>
